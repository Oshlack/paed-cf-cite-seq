---
title: "Analysis of CITE-seq Data"
subtitle: "Preprocessing"
author: "Jovana Maksimovic (modified from code by Peter Hickey & William Ho)"
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: inline
bibliography: ref.bib
site: workflowr::wflow_site
output:
  bookdown::html_document2:
    base_format: workflowr::wflow_html
    toc: yes
    toc_float: yes
    theme: cosmo
    highlight: textmate
    number_sections: true
---

```{r, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

# Load libraries

```{r setup}
suppressPackageStartupMessages(library(BiocStyle))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(here))
suppressPackageStartupMessages(library(glue))
suppressPackageStartupMessages(library(DropletUtils))
suppressPackageStartupMessages(library(scran))
suppressPackageStartupMessages(library(scater))
suppressPackageStartupMessages(library(scuttle))
suppressPackageStartupMessages(library(janitor))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(scales))
suppressPackageStartupMessages(library(DropletQC))
suppressPackageStartupMessages(library(EnsDb.Hsapiens.v86))
suppressPackageStartupMessages(library(ensembldb))
```

# Load data

```{r}
sce <- readRDS(
  here("data", "SCEs", "03_C133_Neeland.demultiplexed.SCE.rds"))
```

## Incorporate cell-based annotation

Cell-based annotations are included in the *colData* of the *SingleCellExperiment*.
We store the counts from the hashtag features as an 'alternative experiment'.

```{r}
# Some useful colours
hto_colours <- setNames(
  unique(sce$colours$hto_colours),
  unique(names(sce$colours$hto_colours)))
genetic_donor_colours <- setNames(
  unique(sce$colours$genetic_donor_colours),
  unique(names(sce$colours$genetic_donor_colours)))
capture_colours <- setNames(
  unique(sce$colours$capture_colours),
  unique(names(sce$colours$capture_colours)))
```

### Summary

```{r experiment-by-genetic-donor, fig.asp = 1.5, fig.cap = "Breakdown of the samples by `genetic_donor` and `capture`."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = genetic_donor, fill = HTO),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 10) + 
  scale_fill_manual(values = hto_colours)

p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = genetic_donor, fill = capture),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 10) + 
  scale_fill_manual(values = capture_colours)

p3 <- ggcells(sce) + 
  geom_bar(aes(x = genetic_donor, fill = genetic_donor)) + 
  coord_flip() + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 10) + 
  scale_fill_manual(values = genetic_donor_colours) +
  geom_text(stat='count', aes(x = genetic_donor, label=..count..), hjust=1.5, size=2) +
  guides(fill = FALSE)

p1 / p2 / p3 
```

## Incorporating gene-based annotation

Having quantified gene expression against the Ensembl gene annotation, we have Ensembl-style identifiers for the genes. 
These identifiers are used as they are unambiguous and highly stable. 
However, they are difficult to interpret compared to the gene symbols which are more commonly used in the literature.
Given the Ensembl identifiers, we obtain the corresponding gene symbols using annotation packages available through Bioconductor.
Henceforth, we will use gene symbols (where available) to refer to genes in our analysis and otherwise use the Ensembl-style gene identifiers^[Some care is taken to account for missing and duplicate gene symbols; missing symbols are replaced with the Ensembl identifier and duplicated symbols are concatenated with the (unique) Ensembl identifiers.].

```{r, warning=FALSE, message=FALSE}
rownames(sce) <- uniquifyFeatureNames(rowData(sce)$ID, rowData(sce)$Symbol)
# Add chromosome location so we can filter on mitochondrial genes.
location <- mapIds(
  x = EnsDb.Hsapiens.v86,
  # NOTE: Need to remove gene version number prior to lookup.
  keys = rowData(sce)$ID,
  keytype = "GENEID",
  column = "SEQNAME")
rowData(sce)$CHR <- location
# Additional gene metadata from ENSEMBL and NCBI
# NOTE: These columns were customised for this project.
ensdb_columns <- c(
  "GENEBIOTYPE", "GENENAME", "GENESEQSTART", "GENESEQEND", "SEQNAME", "SYMBOL")
names(ensdb_columns) <- paste0("ENSEMBL.", ensdb_columns)
stopifnot(all(ensdb_columns %in% columns(EnsDb.Hsapiens.v86)))
ensdb_df <- DataFrame(
  lapply(ensdb_columns, function(column) {
    mapIds(
      x = EnsDb.Hsapiens.v86,
      keys = rowData(sce)$ID,
      keytype = "GENEID",
      column = column,
      multiVals = "CharacterList")
  }),
  row.names = rowData(sce)$ID)
# NOTE: Can't look up GENEID column with GENEID key, so have to add manually.
ensdb_df$ENSEMBL.GENEID <- rowData(sce)$ID
# NOTE: Homo.sapiens combines org.Hs.eg.db and
#       TxDb.Hsapiens.UCSC.hg19.knownGene (as well as others) and therefore
#       uses entrez gene and RefSeq based data.
library(Homo.sapiens)
# NOTE: These columns were customised for this project.
ncbi_columns <- c(
  # From TxDB: None required
  # From OrgDB
  "ALIAS", "ENTREZID", "GENENAME", "REFSEQ", "SYMBOL")
names(ncbi_columns) <- paste0("NCBI.", ncbi_columns)
stopifnot(all(ncbi_columns %in% columns(Homo.sapiens)))
ncbi_df <- DataFrame(
  lapply(ncbi_columns, function(column) {
    mapIds(
      x = Homo.sapiens,
      keys = rowData(sce)$ID,
      keytype = "ENSEMBL",
      column = column,
      multiVals = "CharacterList")
  }),
  row.names = rowData(sce)$ID)
rowData(sce) <- cbind(rowData(sce), ensdb_df, ncbi_df)
# Some useful gene sets
mito_set <- rownames(sce)[which(rowData(sce)$CHR == "MT")]
ribo_set <- grep("^RP(S|L)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$human_gene_symbol)
is_ribo <- rownames(sce) %in% ribo_set
sex_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME %in% c("X", "Y"))]
pseudogene_set <- rownames(sce)[
  any(grepl("pseudogene", rowData(sce)$ENSEMBL.GENEBIOTYPE))]

head(rowData(sce)) %>%
  knitr::kable()
```

# Quality control

## Define the quality control metrics

Low-quality cells need to be removed to ensure that technical effects do not distort downstream analysis results.
We use several quality control (QC) metrics to measure the quality of the cells:

- `sum`: This measures the library size of the cells, which is the total sum of counts across both genes and spike-in transcripts. We want cells to have high library sizes as this means more RNA has been successfully captured during library preparation. 
- `detected`: This is the number of expressed features^[The number of expressed features refers to the number of genes which have non-zero counts (i.e. they have been identified in the cell at least once)] in each cell. Cells with few expressed features are likely to be of poor quality, as the diverse transcript population has not been successful captured. 
- `subsets_Mito_percent`: This measures the proportion of UMIs which are mapped to mitochondrial RNA. If there is a higher than expected proportion of mitochondrial RNA this is often symptomatic of a cell which is under stress and is therefore of low quality and will not be used for the analysis. 
- `subsets_Ribo_percent`: This measures the proportion of UMIs which are mapped to ribosomal protein genes. If there is a higher than expected proportion of ribosomal protein gene expression this is often symptomatic of a cell which is of compromised quality and we may want to exclude it from the analysis. 

In summary, we aim to identify cells with low library sizes, few expressed genes, and very high percentages of mitochondrial and ribosomal protein gene expression.

```{r, results = "hide"}
is_mito <- rownames(sce) %in% mito_set
summary(is_mito)
is_ribo <- rownames(sce) %in% ribo_set
summary(is_ribo)
sce <- addPerCellQC(
  sce, 
  subsets = list(Mito = which(is_mito), Ribo = which(is_ribo)))
```

## Visualise the QC metrics

Figure \@ref(fig:qcplot-by-genetic-donor) shows that the vast majority of samples are good-quality:

- The median library size is around `r number(median(sce$sum), accuracy = 100, big.mark = ",")`^[This is consistent with the use of UMI counts rather than read counts, as each transcript molecule can only produce one UMI count but can yield many reads after fragmentation.].
- The median number of genes detected is around `r number(median(sce$detected), accuracy = 100, big.mark = ",")`.
- The median percentage of UMIs that are mapped to mitochondrial RNA is around  `r percent(median(sce$subsets_Mito_percent), scale = 1)`

However, the percentage of UMIs that are mapped to ribosomal protein genes is perhaps higher than we would like at `r percent(median(sce$subsets_Ribo_percent), scale = 1)`.

As we would expect, the `doublet` droplets have larger library sizes and more genes detected.
The `unassigned` droplets generally have smaller library sizes and fewer genes detected.

```{r qcplot-by-genetic-donor, fig.cap = "Distributions of various QC metrics for all cells in the dataset. This includes the library sizes, number of genes detected, and percentage of reads mapped to mitochondrial genes.", fig.asp = 2 / 3}
p1 <- plotColData(
  sce,
  "sum",
  x = "genetic_donor",
  other_fields = c("capture", "HTO"),
  colour_by = "genetic_donor",
  point_size = 0.5) +
  scale_y_log10() +
  scale_colour_manual(values = genetic_donor_colours, name = "genetic_donor") +
  theme(axis.text.x = element_blank()) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))
p2 <- plotColData(
  sce,
  "detected",
  x = "genetic_donor",
  other_fields = c("capture", "HTO"),
  colour_by = "genetic_donor",
  point_size = 0.5) +
  scale_colour_manual(values = genetic_donor_colours, name = "genetic_donor") +
  theme(axis.text.x = element_blank())
p3 <- plotColData(
  sce,
  "subsets_Mito_percent",
  x = "genetic_donor",
  other_fields = c("capture", "HTO"),
  colour_by = "genetic_donor",
  point_size = 0.5) +
  scale_colour_manual(values = genetic_donor_colours, name = "genetic_donor") +
  theme(axis.text.x = element_blank())
p4 <- plotColData(
  sce,
  "subsets_Ribo_percent",
  x = "genetic_donor",
  other_fields = c("capture", "HTO"),
  colour_by = "genetic_donor",
  point_size = 0.5) +
  scale_colour_manual(values = genetic_donor_colours, name = "genetic_donor") +
  theme(axis.text.x = element_blank())
p1 + p2 + p3 + p4 + plot_layout(guides = "collect", ncol = 2)
```

Figures \@ref(fig:sum-faceted-genetic-donor) - \@ref(fig:ribo-faceted-genetic-donor) stratify each of the panels in \@ref(fig:qcplot-by-genetic-donor) by `capture` and `genetic_donor`.

```{r sum-faceted-genetic-donor, fig.cap = "Library size per droplet stratified by `capture` and `HTO`", fig.asp = 2 / 3, layout = "l-page"}
p1 + facet_grid(capture ~ HTO) + 
  theme(legend.position="bottom", text = element_text(size=6), axis.text.y = element_text(size=6)) 
```

```{r detected-faceted-genetic-donor, fig.cap = "Number of genes detected per droplet stratified by `capture` and `HTO`", fig.asp = 2 / 3, layout = "l-page"}
p2 + facet_grid(capture ~ HTO) + 
  theme(legend.position="bottom", text = element_text(size=6), axis.text.y = element_text(size=6)) 
```

```{r mito-faceted-genetic-donor, fig.cap = "Percentage of UMIs that are mapped to mitochondrial RNA per droplet stratified by `capture` and `HTO`", fig.asp = 2 / 3, layout = "l-page"}
p3 + facet_grid(capture ~ HTO) + 
  theme(legend.position="bottom", text = element_text(size=6), axis.text.y = element_text(size=6)) 
```

```{r ribo-faceted-genetic-donor, fig.cap = "Percentage of UMIs that are mapped to ribosomal protein genes per droplet stratified by `capture` and `HTO`", fig.asp = 2 / 3, layout = "l-page"}
p4 + facet_grid(capture ~ HTO) + 
  theme(legend.position="bottom", text = element_text(size=6), axis.text.y = element_text(size=6)) 
```

## Identify outliers by each metric

Filtering on the mitochondrial proportion can identify stressed/damaged cells and so we seek to identify droplets with unusually large mitochondrial proportions (i.e. outliers). Outlier thresholds are defined based on the median absolute deviation (MADs) from the median value of the metric across all cells. Here, we opt to use `donor`-specific thresholds to account for `donor`-specific differences^[It is important to note that we only using droplets assigned to a sample (i.e. we ignore `unassigned` droplets) for the calculation of these thresholds.].

```{r}
sce$batch <- sce$genetic_donor

mito_drop <- isOutlier(
  metric = sce$subsets_Mito_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$batch,
  subset = !grepl("unassigned", sce$genetic_donor))
mito_drop_df <- data.frame(
  sample = factor(
    colnames(attributes(mito_drop)$thresholds),
    levels(sce$batch)),
  lower = attributes(mito_drop)$thresholds["higher", ])
ribo_drop <- isOutlier(
  metric = sce$subsets_Ribo_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$batch,
  subset = !grepl("unassigned", sce$genetic_donor))
ribo_drop_df <- data.frame(
  sample = factor(
    colnames(attributes(ribo_drop)$thresholds),
    levels(sce$batch)),
  lower = attributes(ribo_drop)$thresholds["higher", ])
```

The following table summarises the QC cutoffs:

```{r}
qc_cutoffs_df <- dplyr::inner_join(mito_drop_df, ribo_drop_df, by = "sample")
colnames(qc_cutoffs_df) <- c("batch", "%mito", "%ribo")
inner_join(
  qc_cutoffs_df,
  distinct(as.data.frame(colData(sce)[, c("batch"), drop = FALSE])),
  by = "batch") %>%
  dplyr::select(batch, everything()) %>%
  arrange(batch) %>%
  knitr::kable(caption = "Sample-specific QC metric cutoffs", digits = 1)
```

The vast majority of cells are retained for all samples.

```{r}
sce_pre_QC_outlier_removal <- sce
# TODO: Decide if excluding based on ribo
keep <- !mito_drop
sce_pre_QC_outlier_removal$keep <- keep
sce <- sce[, keep]
data.frame(
  ByMito = tapply(
    mito_drop, 
    sce_pre_QC_outlier_removal$batch, 
    sum,
    na.rm = TRUE),
  Remaining = as.vector(unname(table(sce$batch))),
  PercRemaining = round(
    100 * as.vector(unname(table(sce$batch))) /
      as.vector(
        unname(
          table(sce_pre_QC_outlier_removal$batch))), 1)) %>%
  tibble::rownames_to_column("batch") %>%
  dplyr::arrange(dplyr::desc(PercRemaining)) %>%
  knitr::kable(
    caption = "Number of samples removed by each QC step and the number of samples remaining.")
```

### Checking for removal of biologically relevant subpopulations

The biggest practical concern during QC is whether an entire cell type is inadvertently discarded.
There is always some risk of this occurring as the QC metrics are never fully independent of biological state.
We can diagnose cell type loss by looking for systematic differences in gene expression between the discarded and retained cells.

```{r}
lost <- calculateAverage(counts(sce_pre_QC_outlier_removal)[, !keep])
kept <- calculateAverage(counts(sce_pre_QC_outlier_removal)[, keep])
library(edgeR)
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.
Figure \@ref(fig:qc-md-plot-C133-Neeland) shows the result of this analysis, highlighting that the systematically upregulated genes are mitochondrial transcripts and that those systematically downregulated genes are largely ribosomal protein genes.
This suggests that the QC step did not inadvertently filter out an entire biologically relevant subpopulation.

```{r qc-md-plot-C133-Neeland, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
par(mfrow = c(1, 1))
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)
```

Another concern is whether the cells removed during QC preferentially derive from particular experimental groups.
Reassuringly, Figure \@ref(fig:barplot-highlighting-outliers) shows that this is not the case.

```{r barplot-highlighting-outliers, fig.cap = "Droplets removed during QC, stratified by `Sample`. ", fig.asp = 1.5}
ggcells(sce_pre_QC_outlier_removal) +
  geom_bar(aes(x = genetic_donor, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 7) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(genetic_donor ~ ., scales = "free_y")
```

Finally, Figure \@ref(fig:qcplot-highlighting-outliers) compares the QC metrics of the discarded and retained droplets.

```{r qcplot-highlighting-outliers, fig.cap = "Distribution of QC metrics for each plate in the dataset. Each point represents a cell and is colored according to whether it was discarded during the QC process. Note that a cell will only be kept if it passes the relevant threshold for all QC metrics.", fig.asp = 1}
p1 <- plotColData(
  sce_pre_QC_outlier_removal,
  "sum",
  x = "genetic_donor",
  colour_by = "keep",
  point_size = 0.5) +
  scale_y_log10() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))
p2 <- plotColData(
  sce_pre_QC_outlier_removal,
  "detected",
  x = "genetic_donor",
  colour_by = "keep",
  point_size = 0.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p3 <- plotColData(
  sce_pre_QC_outlier_removal,
  "subsets_Mito_percent",
  x = "genetic_donor",
  colour_by = "keep",
  point_size = 0.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p4 <- plotColData(
  sce_pre_QC_outlier_removal,
  "subsets_Ribo_percent",
  x = "genetic_donor",
  colour_by = "keep",
  point_size = 0.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p1 + p2 + p3 + p4 + plot_layout(guides = "collect")
```

## QC summary

We had already removed droplets that have unusually small library sizes or number of genes detected by the process of identifying empty droplets.
We have now further removed droplets whose mitochondrial proportions we deem to be an outlier.

For the time being, we opt to retain the `Unknown` and `unassigned` droplets because these may allow us to identify a subpopulation of cells that are not captured by hashing or genetic demultiplexing.

To conclude, Figure \@ref(fig:qcplot-post-outlier-removal) shows that following QC that most samples have similar QC metrics, as is to be expected, and Figure\@ref(fig:experiment-by-donor-postqc) summarises the experimental design following QC.

```{r qcplot-post-outlier-removal, fig.cap = "Distributions of various QC metrics for all cells in the dataset passing QC. This includes the library sizes and proportion of reads mapped to mitochondrial genes.", fig.asp = 1}
p1 <- plotColData(
  sce,
  "sum",
  x = "genetic_donor",
  other_fields = c("capture", "genetic_donor"),
  colour_by = "genetic_donor",
  point_size = 0.5) +
  scale_y_log10() +
  scale_colour_manual(values = genetic_donor_colours, name = "genetic_donor") +
  theme(axis.text.x = element_blank()) +
  annotation_logticks(
    sides = "l",
    short = unit(0.03, "cm"),
    mid = unit(0.06, "cm"),
    long = unit(0.09, "cm"))
p2 <- plotColData(
  sce,
  "detected",
  x = "genetic_donor",
  other_fields = c("capture", "genetic_donor"),
  colour_by = "genetic_donor",
  point_size = 0.5) +
  scale_colour_manual(values = genetic_donor_colours, name = "genetic_donor") +
  theme(axis.text.x = element_blank())
p3 <- plotColData(
  sce,
  "subsets_Mito_percent",
  x = "genetic_donor",
  other_fields = c("capture", "genetic_donor"),
  colour_by = "genetic_donor",
  point_size = 0.5) +
  scale_colour_manual(values = genetic_donor_colours, name = "genetic_donor") +
  theme(axis.text.x = element_blank())
p4 <- plotColData(
  sce,
  "subsets_Ribo_percent",
  x = "genetic_donor",
  other_fields = c("capture", "genetic_donor"),
  colour_by = "genetic_donor",
  point_size = 0.5) +
  scale_colour_manual(values = genetic_donor_colours, name = "genetic_donor") +
  theme(axis.text.x = element_blank())
p1 + p2 + p3 + p4 + plot_layout(guides = "collect", ncol = 2)
```

```{r experiment-by-donor-postqc, fig.asp = 1.5, fig.cap = "Breakdown of the samples following QC."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = genetic_donor, fill = HTO),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 10) + 
  scale_fill_manual(values = hto_colours)
p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = genetic_donor, fill = capture),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  theme_cowplot(font_size = 10) + 
  scale_fill_manual(values = capture_colours)
p3 <- ggcells(sce) + 
  geom_bar(aes(x = genetic_donor, fill = genetic_donor)) + 
  coord_flip() + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 10) + 
  scale_fill_manual(values = genetic_donor_colours) +
  geom_text(stat='count', aes(x = genetic_donor, label=..count..), hjust=1.5, size=2) +
  guides(fill = FALSE)
p1 / p2 / p3 + plot_layout(guides = "collect")
```

# Identify further empty droplets using `DropletQC`

`DropletQC` calculates, for every requested cell barcode in a provided scRNA-seq BAM file, the nuclear fraction score:

`nuclear fraction = intronic reads / (intronic  reads  +  exonic  reads)`

The score captures the proportion of reads from intronic regions. These RNA fragments originate from unspliced (nuclear) pre-mRNA, hence the name “nuclear fraction”. This score can be used to help identify:

1. “Empty” droplets containing ambient RNA: low nuclear fraction score and low UMI count
2. Droplets containing damaged cells: high nuclear fraction score and low UMI count

```{r, message=FALSE, warning=FALSE}
out <- here("data/SCEs/03_C133_Neeland.nuclear_fraction_calls.rds")
capture_names <- levels(sce$capture)

if(!file.exists(out)){
folder <- here()

nf <- lapply(capture_names, function(cn){
  message(cn)
  
  bam <- file.path(folder, 
                   "data/CellRanger",
                   cn,
                   "possorted_genome_bam.bam")
  bai <- file.path(folder, 
                   "data/CellRanger",
                   cn,
                   "possorted_genome_bam.bam.bai")
  
  nuclear_fraction_tags(bam = bam,
                        bam_index = bai,
                        verbose = FALSE,
                        barcodes = sce[["Barcode"]][sce$Sample == cn])
})
names(nf) <- capture_names

dplyr::bind_rows(lapply(nf, 
                        tibble::rownames_to_column, 
                        var = "barcode")) %>%
  dplyr::mutate(cell = paste(rep(seq_along(nf), 
                                 vapply(nf, nrow, 1L)),
                             barcode, sep = "_")) -> nf_dat
  saveRDS(nf_dat, file = out)
          
} else {
  nf_dat <- readRDS(out)
  
}
```

## Visualise the results

Figure \@ref(fig:dropletqc-results-C133-Neeland) shows that a distinct population of additional empty droplets has not been identified by `DropletQC`. All potential empty droplets will be tagged but downstream removal is unlikely.  

```{r, fig.asp=1}
colData(sce) %>% 
  data.frame %>% 
  rownames_to_column(var = "cell") %>%
  inner_join(nf_dat %>% 
               dplyr::select(cell, nuclear_fraction)) %>%
  column_to_rownames(var = "cell") %>%
  DataFrame -> colData(sce)

ed <- lapply(capture_names, function(cn){
  identify_empty_drops(nf_umi = colData(sce) %>% data.frame %>%
                         dplyr::filter(Sample == cn) %>%
                         dplyr::select(nuclear_fraction, sum),
                       include_plot = TRUE,
                       umi_rescue = 10^2.5,
                       nf_rescue = 0.02)
})
```

Add `DropletQC` calls to `colData`.

```{r dropletqc-results-C133-Neeland, fig.cap = "DropletQC results across all captures."}
colData(sce) %>% 
  data.frame %>% 
  rownames_to_column(var = "cell") %>%
  inner_join(ed %>% bind_rows %>%
               rownames_to_column(var = "cell")) %>%
  column_to_rownames(var = "cell") %>%
  DataFrame -> colData(sce)

p <- ggcells(sce, aes(x = nuclear_fraction, y = sum)) +
  aes(colour = cell_status) +
  geom_point(size = 1, alpha = 0.25) +
  scale_y_log10() +
  facet_wrap(~Sample) +
  theme(legend.position = "bottom")
p
```

```{r}
plotColData(sce, x = "Sample", 
            y = "sum",
            colour_by = "cell_status") +
  scale_y_log10()
```

# Save data

```{r}
out <- here("data", "SCEs", "03_C133_Neeland.preprocessed.SCE.rds") 

if(!file.exists(out)) saveRDS(sce, out)
```

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>
